#!/usr/bin/env python
from __future__ import print_function

import argparse
import codecs
import datetime
import json
import sys
import types
import os

# Python 2 compat
try:
    BrokenPipeError
except NameError:
    import socket
    BrokenPipeError = socket.error

import fitparse


def format_message(num, message, options):
    s = ["{}. {}".format(num, message.name)]
    if options.with_defs:
        s.append(' [{}]'.format(message.type))
    s.append('\n')

    if message.type == 'data':
        for field_data in message:
            s.append(' * {}: {}'.format(field_data.name, field_data.value))
            if field_data.units:
                s.append(' [{}]'.format(field_data.units))
            s.append('\n')

    s.append('\n')
    return "".join(s)


def parse_args(args=None):
    parser = argparse.ArgumentParser(
        description='Dump .FIT files to various formats',
        epilog='python-fitparse version %s' % fitparse.__version__,
    )
    parser.add_argument('-v', '--verbose', action='count', default=0)
    parser.add_argument(
        '-o', '--output', type=argparse.FileType(mode='w'), default="-",
        help='File to output data into (defaults to stdout)',
    )
    parser.add_argument(
        # TODO: csv
        '-t', '--type', choices=('readable', 'json', 'gpx'), default='readable',
        help='File type to output. (DEFAULT: %(default)s)',
    )
    parser.add_argument(
        '-n', '--name', action='append', help='Message name (or number) to filter',
    )
    parser.add_argument(
        'infile', metavar='FITFILE', type=argparse.FileType(mode='rb'),
        help='Input .FIT file (Use - for stdin)',
    )
    parser.add_argument(
        '--ignore-crc', action='store_const', const=True, help='Some devices seem to write invalid crc\'s, ignore these.'
    )

    options = parser.parse_args(args)

    # Work around argparse.FileType not accepting an `encoding` kwarg in
    # Python < 3.4 by closing and reopening the file (unless it's stdout)
    if options.output is not sys.stdout:
        options.output.close()
        options.output = codecs.open(options.output.name, 'w', encoding='UTF-8')

    options.verbose = options.verbose >= 1
    options.with_defs = (options.type == "readable" and options.verbose)
    options.as_dict = (options.type != "readable" and options.verbose)

    return options


class RecordJSONEncoder(json.JSONEncoder):
    def default(self, obj):
        if isinstance(obj, types.GeneratorType):
            return list(obj)
        if isinstance(obj, (datetime.datetime, datetime.time)):
            return obj.isoformat()
        if isinstance(obj, fitparse.DataMessage):
            return {
                "type": obj.name,
                "data": {
                    data.name: data.value for data in obj
                }
            }
        # Fall back to original to raise a TypeError
        return super(RecordJSONEncoder, self).default(obj)


def get_gpsdat(records, src=None, trkname=None):
    gpsdat = {
        'time': None, # in ISO 8601 format
        'src': src,
        'trkname': trkname,
        'trkpts': [],
    }

    for message in records:

        if message.name == 'file_id':
            for field_data in message:
                if field_data.name == 'time_created' and type(field_data.value) == datetime.datetime:
                    gpsdat['time'] = field_data.value.strftime('%Y-%m-%dT%H:%M:%SZ')

        elif message.name == 'record':
            trkpt = {
                'lat': None, # in decimal degrees
                'lon': None, # in decimal degrees
                'ele': None, # in m
                'time': None, # in ISO 8601 format
                'speed': None, # in m/s
            }
            for field_data in message:
                if field_data.name == 'position_lat':
                    trkpt['lat'] = field_data.value
                elif field_data.name == 'position_long':
                    trkpt['lon'] = field_data.value
                elif field_data.name == 'enhanced_altitude':
                    trkpt['ele'] = field_data.value
                elif field_data.name == 'timestamp' and type(field_data.value) == datetime.datetime:
                    trkpt['time'] = field_data.value.strftime('%Y-%m-%dT%H:%M:%SZ')
                elif field_data.name == 'enhanced_speed' and type(field_data.value) == float:
                    if field_data.units == 'm/s':
                        trkpt['speed'] = field_data.value
                    elif field_data.units == 'km/h':
                        trkpt['speed'] = field_data.value / 3.6 # convert to m/s
            gpsdat['trkpts'].append(trkpt)

    return gpsdat


def format_gpx(gpsdat):
    s = []

    # header + open tags
    s.append('<?xml version="1.0"?>\n')
    s.append('<gpx xmlns="http://www.topografix.com/GPX/1/1" version="1.1" creator="python-fitparse (fitdump)" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd">\n')
    s.append('<metadata>\n')
    if gpsdat['time'] is not None:
        s.append('<time>' + gpsdat['time'] + '</time>\n')
    if gpsdat['src'] is not None:
        s.append('<src>' + gpsdat['src'] + '</src>\n')
    s.append('</metadata>\n')
    s.append('<trk>\n')
    if gpsdat['trkname'] is not None:
        s.append('<name>' + gpsdat['trkname'] + '</name>\n')
    s.append('<trkseg>\n')

    # track points
    for dat in gpsdat['trkpts']:
        if dat['lat'] is not None and dat['lon'] is not None:
            s.append('<trkpt lat="' + str(dat['lat']) + '" lon="' + str(dat['lon']) + '">\n')
            if dat['ele'] is not None:
                s.append('<ele>' + str(dat['ele']) + '</ele>\n')
            if dat['time'] is not None:
                s.append('<time>' + str(dat['time']) + '</time>\n')
            if dat['speed'] is not None:
                s.append('<speed>' + str(dat['speed']) + '</speed>\n')
            s.append('</trkpt>\n')

    # close tags
    s.append('</trkseg>\n')
    s.append('</trk>\n')
    s.append('</gpx>\n')

    return s


def main(args=None):
    options = parse_args(args)

    fitfile = fitparse.FitFile(
        options.infile,
        data_processor=fitparse.StandardUnitsDataProcessor(),
        check_crc = not(options.ignore_crc),
    )
    records = fitfile.get_messages(
        name=options.name,
        with_definitions=options.with_defs,
        as_dict=options.as_dict
    )

    try:
        if options.type == "json":
            json.dump(records, fp=options.output, cls=RecordJSONEncoder)
        elif options.type == "readable":
            options.output.writelines(format_message(n, record, options)
                                      for n, record in enumerate(records, 1))
        elif options.type == "gpx":
            src_filename = os.path.basename(options.infile.name)
            gpsdat = get_gpsdat(records, src=src_filename, trkname=src_filename)
            options.output.writelines(format_gpx(gpsdat))
    finally:
        try:
            options.output.close()
        except IOError:
            pass

if __name__ == '__main__':
    try:
        main()
    except BrokenPipeError:
        pass
